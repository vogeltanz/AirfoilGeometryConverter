#include <math.h>
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <sstream>

#include "Version.h"
#include "Airfoil.h"
#include "StringUtil.h"

using namespace std;


//==== Constructor ====//
Airfoil::Airfoil( )
{
    // Initialize to closed circle.
    int n = 21;
    for ( int i = 0; i < n; i++ )
    {
        double theta = M_PI-M_PI*i/(n-1);
		Point ini0 = { 0.5 + 0.5*cos(theta), 0.5*sin(theta), 0.0 };
        m_UpperPnts.push_back( ini0 );
        theta = M_PI+M_PI*i/(n-1);
		Point ini1 = { 0.5 + 0.5*cos(theta), 0.5*sin(theta), 0.0 };
        m_LowerPnts.push_back( ini1 );
    }
}

Airfoil::~Airfoil()
{
	
}



bool Airfoil::ExportDAT(string file_name, FormatDAT formatDAT, unsigned int decimalPlacesPrecision)
{
	this->m_AirfoilName = file_name;
	
	//create string with the airfoil points which are specifically formatted (selig/lednicer)
	//string format = "";
	string DATfile = "";
	if (formatDAT == selig)
	{
		DATfile = this->ConvertMeshToSelig(decimalPlacesPrecision);
		//format = "selig";
	}
	else if (formatDAT == lednicer)
	{
		DATfile = this->ConvertMeshToLednicer(decimalPlacesPrecision);
		//format = "lednicer";
	}
	
	
	//write the string to the output file
	ofstream datFile(file_name.append(".dat" /*format.insert(0, ".")*/).c_str());
	if (datFile.is_open() == true)
	{
		datFile << this->m_AirfoilName << "  //Generated by Airfoil Geometry Converter " << Version << " (Author: Tomas Vogeltanz)" << endl;
		datFile << DATfile;
		datFile.close();
		return true;
	}
	else
		cout << endl << "Unable to write file!" << endl;
	
	
	return false;
}


string Airfoil::ConvertMeshToSelig(unsigned int decimalPlacesPrecision)
{
	string precision = "";
	precision.append("%.");
	precision.append(StringUtil::int_to_string(decimalPlacesPrecision, "%d"));
	precision.append("f");
	
	string output = "";
	
	if (this->m_UpperPnts.size() > 0 && this->m_LowerPnts.size() > 0)
	{
		for (int i = this->m_UpperPnts.size() - 1; i >= 0 ; --i)
		{
			output.append("  ");
			output.append(StringUtil::double_to_string(this->m_UpperPnts[i].x, precision.c_str()));
			m_UpperPnts[i].y >= 0? output.append("  ") : output.append(" ");
			output.append(StringUtil::double_to_string(this->m_UpperPnts[i].y, precision.c_str()));
			output.append("\n");
		}
		
		for (unsigned int i = 0; i < this->m_LowerPnts.size(); ++i)
		{
			if (this->m_LowerPnts[i].x == 0 && this->m_LowerPnts[i].y == 0)
			{
				continue;
			}
			
			output.append("  ");
			output.append(StringUtil::double_to_string(this->m_LowerPnts[i].x, precision.c_str()));
			m_LowerPnts[i].y >= 0? output.append("  ") : output.append(" ");
			output.append(StringUtil::double_to_string(this->m_LowerPnts[i].y, precision.c_str()));
			output.append("\n");
		}
	}
	
	return output;
}


string Airfoil::ConvertMeshToLednicer(unsigned int decimalPlacesPrecision)
{
	string precision = "";
	precision.append("%.");
	precision.append(StringUtil::int_to_string(decimalPlacesPrecision, "%d"));
	precision.append("f");
	
	string output = "";
	
	if (this->m_UpperPnts.size() > 0 && this->m_LowerPnts.size() > 0)
	{
		output.append("       ");
		output.append(StringUtil::int_to_string(this->m_UpperPnts.size(), "%d"));
		output.append(".       ");
		output.append(StringUtil::int_to_string(this->m_LowerPnts.size(), "%d"));
		output.append(".\n");
		
		output.append("\n");
		
		for (unsigned int i = 0; i < this->m_UpperPnts.size(); ++i)
		{
			output.append("  ");
			output.append(StringUtil::double_to_string(this->m_UpperPnts[i].x, precision.c_str()));
			m_UpperPnts[i].y >= 0? output.append("  ") : output.append(" ");
			output.append(StringUtil::double_to_string(this->m_UpperPnts[i].y, precision.c_str()));
			output.append("\n");
		}
		
		output.append("\n");
		
		for (unsigned int i = 0; i < this->m_LowerPnts.size(); ++i)
		{
			output.append("  ");
			output.append(StringUtil::double_to_string(this->m_LowerPnts[i].x, precision.c_str()));
			m_LowerPnts[i].y >= 0? output.append("  ") : output.append(" ");
			output.append(StringUtil::double_to_string(this->m_LowerPnts[i].y, precision.c_str()));
			output.append("\n");
		}
	}
	
	return output;
}



void Airfoil::ExportMesh(string file_name, string format, string mshMin, string mshMax)
{
	//this method uses Gmsh application for meshing the GEO file to SU2 or MSH file format
	//example: gmsh t1.geo -2
	//useful options:
	//-1, -2, -3	Perform 1D, 2D or 3D mesh generation, then exit
	//-o file Specify output file name
	//-format string	Select output mesh format (auto (default), msh, msh1, msh2, unv, vrml, ply2, stl, mesh, bdf, cgns, p3d, diff, med, ...)
	//-clmin float	Set minimum mesh element size
	//-clmax float	Set maximum mesh element size
	//-clscale float	Set global mesh element size scaling factor
	//-algo string	Select mesh algorithm (meshadapt, del2d, front2d, delquad, del3d, front3d, mmg3d, pack)
	//-smooth int	Set number of mesh smoothing steps
	//-optimize_lloyd	Optimize 2D meshes using Lloyd algorithm
	//-ignorePartBound	Ignore partitions boundaries
	//-saveall Save all elements (discard physical group definitions)
	//-check 	Perform various consistency checks on mesh
	string file_nameCopy = file_name;
	string formatCopy = format;
	
	string commandString = "gmsh.exe \"%s\" -2 -o \"%s\" -format \"%s\" -clmin %s -clmax %s";
	char command[2048];
	sprintf (command, commandString.c_str(),
					file_nameCopy.append(".geo").c_str(),
					file_name.append(formatCopy.insert(0, ".")).c_str(),
					format.c_str(),
					mshMin.c_str(),
					mshMax.c_str());
	system(command);
}


bool Airfoil::ExportGEO(string file_name, FarfieldShape farfieldShape, unsigned int farfieldSize, unsigned int decimalPlacesPrecision)
{
	ofstream geoFile(file_name.append(".geo").c_str());
	if (geoFile.is_open())
	{
		geoFile << this->ConvertAirfoilToGEO(farfieldShape, farfieldSize, decimalPlacesPrecision);
		geoFile.close();
		return true;
	}
	else
		cout << endl << "Unable to write file!" << endl;
		
	return false;
}


string Airfoil::ConvertAirfoilToGEO(FarfieldShape farfieldShape, unsigned int farfieldSize, unsigned int decimalPlacesPrecision)
{
	string geoFileString = "";
	vector<unsigned int> airfoilConnectionIDs;
	vector<unsigned int> farfieldConnectionIDs;
	unsigned int numberOfFarfieldPoints = 0;
	int numberOfFarfieldPoints_circleCorrection = 0;
	
	
	//if the first point of the m_LowerPnts list is the same as the first point of the m_UpperPnts list than delete the first point from m_LowerPnts
	if ( m_LowerPnts[0].x == m_UpperPnts[0].x && m_LowerPnts[0].y == m_UpperPnts[0].y )
	{
		m_LowerPnts.erase(m_LowerPnts.begin());
	}
	//if the last point of the m_LowerPnts list is the same as the last point of the m_UpperPnts list than delete the last point from m_LowerPnts
	if ( m_LowerPnts[m_LowerPnts.size() - 1].x == m_UpperPnts[m_UpperPnts.size() - 1].x && m_LowerPnts[m_LowerPnts.size() - 1].y == m_UpperPnts[m_UpperPnts.size() - 1].y )
	{
		m_LowerPnts.erase(m_LowerPnts.begin() + m_LowerPnts.size() - 1);
	}
	
	
	
	//information about the generator and author
	geoFileString.append("//Generated by Airfoil Geometry Converter ");
	geoFileString.append(Version);
	geoFileString.append(" (Author: Tomas Vogeltanz, 2015/2016, Tomas Bata University, Czech Republic)\n\n\n");
	
	
	
	
	//conversion to GEO file format
	//creation of GEO points
	
	//precision of airfoil points
	string precision = "";
	precision.append("%.");
	precision.append(StringUtil::int_to_string(decimalPlacesPrecision, "%d"));
	precision.append("f, ");
	
	//for airfoil
	geoFileString.append("//airfoil points\n\n");
	for (unsigned int i = 0; i < m_UpperPnts.size(); ++i)
	{
		string point = StringUtil::int_to_string(i+1, "Point(%d) = { ");
		geoFileString.append(point);
		point = StringUtil::double_to_string(m_UpperPnts[i].x, precision.c_str());
		geoFileString.append(point);
		point = StringUtil::double_to_string(m_UpperPnts[i].y, precision.c_str());
		geoFileString.append(point);
		point = "0.0 };\n";
		geoFileString.append(point);
		/*string point = "Point(" + i+1 + ") = { " + m_UpperPnts[i].x + ", " + m_UpperPnts[i].y + " , 0.0 };\n";
		geoFileString.append("Point(%d) = { %f, %f, 0.0 };\n", i+1, m_UpperPnts[i].x, m_UpperPnts[i].y);*/
	}
	for (int i = m_LowerPnts.size() - 1; i >= 0; --i)
	{
		string point = StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() - i, "Point(%d) = { ");
		geoFileString.append(point);
		point = StringUtil::double_to_string(m_LowerPnts[i].x, precision.c_str());
		geoFileString.append(point);
		point = StringUtil::double_to_string(m_LowerPnts[i].y, precision.c_str());
		geoFileString.append(point);
		point = "0.0 };\n";
		geoFileString.append(point);
	}
	
	//for farfield
	geoFileString.append("\n//farfield points\n\n");
	if (farfieldShape == Circle)
	{
		numberOfFarfieldPoints = 3;
		numberOfFarfieldPoints_circleCorrection = -1;
		
		//airfoil starts at point 0,0 and ends approximately at 1,0; thus the center should be somewhere between those values (i.e. 0.5, 0)
		string point = StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 1, "Point(%d) = {0.5, 0, 0};\n");
		geoFileString.append(point);
		
		point = "Point(";
		point.append(StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 2, "%d"));
		point.append(") = {");
		point.append(StringUtil::int_to_string(farfieldSize, "%d"));
		point.append(", 0, 0};\n");
		//"Point(%d) = {25, 0, 0};\n"
		
		geoFileString.append(point);
		point = "Point(";
		point.append(StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 3, "%d"));
		point.append(") = {");
		point.append(StringUtil::int_to_string((farfieldSize - 1) * (0-1), "%d"));
		point.append(", 0, 0};\n");
		//"Point(%d) = {-24, 0, 0};\n"
		geoFileString.append(point);
		
	}
	else if (farfieldShape == Rectangle)
	{
		numberOfFarfieldPoints = 4;
		
		//airfoil starts at point 0,0 and ends approximately at 1,0; thus the rectangle should start at minimal 'x' + 0.5
		string point = "Point(";
		point.append(StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 1, "%d"));
		point.append(") = {");
		point.append(StringUtil::int_to_string((farfieldSize - 1) * (0-1), "%d"));
		point.append(", ");
		point.append(StringUtil::int_to_string(farfieldSize, "%d"));
		point.append(", 0};\n");
		//"Point(%d) = {-24, 25, 0};\n"
		geoFileString.append(point);
		
		point = "Point(";
		point.append(StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 2, "%d"));
		point.append(") = {");
		point.append(StringUtil::int_to_string(farfieldSize, "%d"));
		point.append(", ");
		point.append(StringUtil::int_to_string(farfieldSize, "%d"));
		point.append(", 0};\n");
		//"Point(%d) = {25, 25, 0};\n"
		geoFileString.append(point);
		
		point = "Point(";
		point.append(StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 3, "%d"));
		point.append(") = {");
		point.append(StringUtil::int_to_string(farfieldSize, "%d"));
		point.append(", ");
		point.append(StringUtil::int_to_string(farfieldSize * (0-1), "%d"));
		point.append(", 0};\n");
		//"Point(%d) = {25, -25, 0};\n"
		geoFileString.append(point);
		
		point = "Point(";
		point.append(StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 4, "%d"));
		point.append(") = {");
		point.append(StringUtil::int_to_string((farfieldSize - 1) * (0-1), "%d"));
		point.append(", ");
		point.append(StringUtil::int_to_string(farfieldSize * (0-1), "%d"));
		point.append(", 0};\n");
		//"Point(%d) = {-24, -25, 0};\n"
		geoFileString.append(point);
	}
	
	
	
	//creation of GEO lines
	
	//for airfoil
	geoFileString.append("\n\n//airfoil lines\n\n");
	
	for (int i = m_LowerPnts.size() + m_UpperPnts.size(); i > 0; --i)
	{
		string point = StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + numberOfFarfieldPoints + m_UpperPnts.size() + m_LowerPnts.size() - i + 1, "Line(%d) = { ");
		geoFileString.append(point);
		point = StringUtil::int_to_string(i, "%d, ");
		geoFileString.append(point);
		if (i != 1)
		{
			point = StringUtil::int_to_string(i-1, "%d };\n");
		}
		else
		{
			//the connection of the last point with the first point
			point = StringUtil::int_to_string(m_LowerPnts.size() + m_UpperPnts.size(), "%d };\n");
		}
		geoFileString.append(point);
	}
	
	
	//for farfield
	if (farfieldShape == Circle)
	{
		geoFileString.append("\n\n//farfield arcs (i.e. circle)\n\n");
		
		/*
		geoFileString.append("Circle(%d) = {%d, %d, %d};\n");
		geoFileString.append("Circle(%d) = {%d, %d, %d};\n");*/
		
		string point = StringUtil::int_to_string(2 * m_UpperPnts.size() + 2 * m_LowerPnts.size() + numberOfFarfieldPoints + 1, "Circle(%d) = { ");
		geoFileString.append(point);
		point = StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 2, "%d, ");
		geoFileString.append(point);
		point = StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 1, "%d, ");
		geoFileString.append(point);
		point = StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 3, "%d };\n");
		geoFileString.append(point);
		
		point = StringUtil::int_to_string(2 * m_UpperPnts.size() + 2 * m_LowerPnts.size() + numberOfFarfieldPoints + 2, "Circle(%d) = { ");
		geoFileString.append(point);
		point = StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 3, "%d, ");
		geoFileString.append(point);
		point = StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 1, "%d, ");
		geoFileString.append(point);
		point = StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 2, "%d };\n");
		geoFileString.append(point);
		
	}
	else if (farfieldShape == Rectangle)
	{
		geoFileString.append("\n\n//farfield lines\n\n");
		
		/*
		geoFileString.append("Line(%d) = { 103, 104 };\n");
		geoFileString.append("Line(%d) = { 104, 105 };\n");
		geoFileString.append("Line(%d) = { 105, 106 };\n");
		geoFileString.append("Line(%d) = { 106, 103 };\n");*/
		
		for (unsigned int i = 2 * m_UpperPnts.size() + 2 * m_LowerPnts.size() + numberOfFarfieldPoints + 1; i < 2 * m_UpperPnts.size() + 2 * m_LowerPnts.size() + 2 * numberOfFarfieldPoints + 1; ++i)
		{
			string point = StringUtil::int_to_string(i, "Line(%d) = { ");
			geoFileString.append(point);
			point = StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 
							2 * m_UpperPnts.size() + 2 * m_LowerPnts.size() + 2 * numberOfFarfieldPoints + 1 - i, "%d, ");
			geoFileString.append(point);
			if (i != 2 * m_UpperPnts.size() + 2 * m_LowerPnts.size() + 2 * numberOfFarfieldPoints)
			{
				point = StringUtil::int_to_string(m_UpperPnts.size() + m_LowerPnts.size() + 
							2 * m_UpperPnts.size() + 2 * m_LowerPnts.size() + 2 * numberOfFarfieldPoints + 1 - i - 1, "%d };\n");
			}
			else
			{
				//the connection of the last point with the first point
				point = StringUtil::int_to_string(m_LowerPnts.size() + m_UpperPnts.size() + numberOfFarfieldPoints, "%d };\n");
			}
			geoFileString.append(point);
		}
	}
	
	
	
	//creation of line loops and physical element groups (Physical Lines)
	
	//for airfoil
	geoFileString.append("\n\n//airfoil line loop and physical line group\n\n");
	
	string lineLoop = StringUtil::int_to_string(2 * m_UpperPnts.size() + 2 * m_LowerPnts.size() + 2 * numberOfFarfieldPoints + numberOfFarfieldPoints_circleCorrection + 1, "Line Loop(%d) = { ");
	geoFileString.append(lineLoop);
	string lines = "";
	for (unsigned int i = 2 * m_LowerPnts.size() + 2 * m_UpperPnts.size() + numberOfFarfieldPoints;
			i > m_LowerPnts.size() + m_UpperPnts.size() + numberOfFarfieldPoints; --i)
	{
		if (i != m_LowerPnts.size() + m_UpperPnts.size() + numberOfFarfieldPoints + 1)
		{
			lines += StringUtil::int_to_string(i, "%d, ");
		}
		else
		{
			//closing bracket and semicolon
			lines += StringUtil::int_to_string(i, "%d };\n");
		}
	}
	geoFileString.append(lines);
	string physicalLine = "\nPhysical Line(\"airfoil\") = { ";
	geoFileString.append(physicalLine);
	geoFileString.append(lines);
	
	
	//for farfield
	geoFileString.append("\n\n//farfield line loop and physical line group\n\n");
	
	lineLoop = StringUtil::int_to_string(2 * m_UpperPnts.size() + 2 * m_LowerPnts.size() + 2 * numberOfFarfieldPoints + numberOfFarfieldPoints_circleCorrection + 2, "Line Loop(%d) = { ");
	geoFileString.append(lineLoop);
	lines = "";
	for (unsigned int i = 2 * m_LowerPnts.size() + 2 * m_UpperPnts.size() + 2 * numberOfFarfieldPoints + numberOfFarfieldPoints_circleCorrection;
			i > 2 * m_LowerPnts.size() + 2 * m_UpperPnts.size() + numberOfFarfieldPoints; --i)
	{
		if (i != 2 * m_LowerPnts.size() + 2 * m_UpperPnts.size() + numberOfFarfieldPoints + 1)
		{
			lines += StringUtil::int_to_string(i, "%d, ");
		}
		else
		{
			//closing bracket and semicolon
			lines += StringUtil::int_to_string(i, "%d };\n");
		}
	}
	geoFileString.append(lines);
	physicalLine = "\nPhysical Line(\"farfield\") = { ";
	geoFileString.append(physicalLine);
	geoFileString.append(lines);
		
	
	//creation of plane surface and physical element groups (Physical Surface)
	geoFileString.append("\n\n//plane and physical surface\n\n");
	
	//for fluid
	//Plane Surface(%d) = { %d, %d };
	//Physical Surface("fluid") = { %d };
	string surface = StringUtil::int_to_string(2 * m_UpperPnts.size() + 2 * m_LowerPnts.size() + 2 * numberOfFarfieldPoints + numberOfFarfieldPoints_circleCorrection + 3, "Plane Surface(%d) = { ");
	surface += StringUtil::int_to_string(2 * m_UpperPnts.size() + 2 * m_LowerPnts.size() + 2 * numberOfFarfieldPoints + numberOfFarfieldPoints_circleCorrection + 1, "%d, ");
	surface += StringUtil::int_to_string(2 * m_UpperPnts.size() + 2 * m_LowerPnts.size() + 2 * numberOfFarfieldPoints + numberOfFarfieldPoints_circleCorrection + 2, "%d };\n");
	geoFileString.append(surface);
	
	surface = StringUtil::int_to_string(2 * m_UpperPnts.size() + 2 * m_LowerPnts.size() + 2 * numberOfFarfieldPoints + numberOfFarfieldPoints_circleCorrection + 3, "\nPhysical Surface(\"fluid\") = { %d };");
	geoFileString.append(surface);
	
	//end of file should be ended by at least 1 empty line
	geoFileString.append("\n\n");
	
	return geoFileString;
}




bool Airfoil::ReadMesh(string file_name, string TAG_airfoil, bool normalizeCoordinates)
{
	/*--- Open grid file ---*/
	ifstream mesh_file;
	mesh_file.open(file_name.c_str(), ios::in);
	
	/*--- Check the grid ---*/
	if (mesh_file.fail() == false)
	{
		//read the first line to check the format
		unsigned int place;
		string text_line;
		
		//Tell me where are you now? FunTom of the Blue Screen
		place = mesh_file.tellg();
		//And what are you reading? FunTom of the Blue Screen
		std::getline(mesh_file, text_line);
		//The file stream is set back to the previous (and actually, the first) position.
		//Back to the past, right? (or future?). FunTom of the Blue Screen
		mesh_file.seekg(place);
		
		//if the first line contains NDIME tag, it is SU2 file format
		//I don't care if the first lines are blank or if there is some white space ... the user must care. FunTom of the Blue Screen
		if(text_line.find("NDIME=",0) != string::npos)
		{
			if (this->ParseSU2(&mesh_file, TAG_airfoil, normalizeCoordinates) == true)
				return true;
		}
		//else if the first line contains $MeshFormat tag, it is MSH file format
		else if (text_line.find("$MeshFormat",0) != string::npos)
		{
			if (this->ParseMSH(&mesh_file, TAG_airfoil, normalizeCoordinates) == true)
				return true;
		}
	}
	
	return false;
}


bool Airfoil::ParseSU2(ifstream* mesh_file, string MARKER_TAG_airfoil, bool normalizeCoordinates)
{
	
	vector<Point> Points;
	vector<Element> elements;
	string text_line;
	unsigned int nDim, nPoint, nMarker;
	bool domain_flag = false;
	
	
	/*--- Read grid file with format SU2 ---*/
	while(std::getline(*mesh_file, text_line))
	{
		/*--- Read the dimension of the problem ---*/
		string::size_type position = text_line.find("NDIME=",0);
		if(position != string::npos)
		{
			if(domain_flag == false)
			{
				text_line.erase(0,6);
				nDim = atoi(text_line.c_str());
	
				if(nDim == 2)
				{
					cout << endl << "Two dimensions - OK" << endl;
				}
				else
				{
					/* if (nDim == 3)*/
					/*cout << endl << "Three dimensional problem." << endl;*/
					cout << endl << "wrong dimension count" << endl;
					return false;
				}
	
				domain_flag = true;
			}
			else
			{
				break;
			}
		}
	
	
	
		/*--- Read number of points ---*/
		position = text_line.find("NPOIN=",0);
		if(position != string::npos)
		{
			text_line.erase(0,6);
	
			/*--- Check for ghost points. ---*/
			std::stringstream test_line(text_line);
			
			unsigned short iCount = 0;
			unsigned long dummyLong;
			while(test_line >> dummyLong)
				iCount++;
	
			/*--- Now read and store the number of points and possible ghost points. ---*/
	
			std::stringstream  stream_line(text_line);
	
			if(iCount == 2 || iCount == 1)
			{
				stream_line >> nPoint;
			}
			else
			{
				cout << endl << "NPOIN improperly specified - failed" << endl;
				return false;
				//exit(EXIT_FAILURE);
			}
	
			for(unsigned long iPoint = 0 ; iPoint < nPoint; ++iPoint)
			{
				std::getline(*mesh_file, text_line);
				std::istringstream point_line(text_line);
	
				switch(nDim)
				{
					case 2:
						double Coord_2D[2];
						point_line >> Coord_2D[0];
						point_line >> Coord_2D[1];
						Point point = { Coord_2D[0], Coord_2D[1], 0.0 };
						Points.push_back(point);
						break;
				}
			}
			
			cout << endl << "Points read - OK" << endl;
		}


	
		/*--- Read number of markers ---*/
		position = text_line.find("NMARK=",0);
		if(position != string::npos)
		{
			text_line.erase(0,6);
			nMarker = atoi(text_line.c_str());
	
			//for all marker tags
			for(unsigned short iMarker = 0 ; iMarker < nMarker; ++iMarker)
			{
				std::getline(*mesh_file, text_line);
				text_line.erase(0,11);
				string::size_type position;
	
				//clean the name of the marker tag
				for(unsigned short iChar = 0; iChar < text_line.length(); iChar++)
				{
					position = text_line.find(" ", 0);
					if(position != string::npos) text_line.erase(position,1);
	
					position = text_line.find("\r", 0);
					if(position != string::npos) text_line.erase(position,1);
	
					position = text_line.find("\n", 0);
					if(position != string::npos) text_line.erase(position,1);
				}
	
				string Marker_Tag = text_line.c_str();
	
				/*--- Physical boundaries definition ---*/
				if(Marker_Tag.compare(MARKER_TAG_airfoil) == 0)
				{
					std::getline(*mesh_file, text_line);
					text_line.erase(0,13);
					unsigned int nElem_Bound = atoi(text_line.c_str());
	
					for(unsigned long iElem_Bound = 0 ; iElem_Bound < nElem_Bound; ++iElem_Bound)
					{
						std::getline(*mesh_file, text_line);
						std::istringstream elemBound_line(text_line);
			
						switch(nDim)
						{
							case 2:
								unsigned int elementTemporary[3];
								elemBound_line >> elementTemporary[0];
								elemBound_line >> elementTemporary[1];
								elemBound_line >> elementTemporary[2];
								Element element = { elementTemporary[0], elementTemporary[1], elementTemporary[2] };
								elements.push_back(element);
								break;
						}
					}
					
					mesh_file->close();
					cout << endl << "Marker tag found - OK" << endl;
					
					if(this->ConvertFromMesh(Points, elements, normalizeCoordinates) == true)
					{
						cout << endl << "Conversion from mesh - OK" << endl;
						return true;
					}
					else
					{
						cout << endl << "Conversion from mesh - failed" << endl;
						return false;
					}
				}
	
			}
			
			cout << endl << "Marker tag was not found - failed" << endl;
	
		}
	
	}
	/*--- Close the input file ---*/
	mesh_file->close();
	return false;
}



bool Airfoil::ParseMSH(ifstream* mesh_file, string PhysicalName_airfoil, bool normalizeCoordinates)
{
	
	vector<Point> Points;
	vector<Element> elements;
	string text_line;
	double version;
	unsigned int fileType, dataSize;
	unsigned int nPhysicalNames, nPoint, nElements;
	bool meshFormat_flag = false;
	unsigned int physicalDimension, physicalNumber;
	bool physicalNameFound = false;
	bool elementsFound = false;
	
	
	/*--- Read grid file with format MSH ---*/
	while(std::getline(*mesh_file, text_line))
	{
		/*--- Read the mesh information ---*/
		string::size_type position = text_line.find("$MeshFormat",0);
		if(position != string::npos)
		{
			std::getline(*mesh_file, text_line);
			std::istringstream line(text_line);
			
			line >> version;
			line >> fileType;
			line >> dataSize;
			
			if(meshFormat_flag == false)
			{
				if(version >= 2)
				{
					cout << endl << "version 2 or higher - OK" << endl;
				}
				else
				{
					cout << endl << "wrong version - failed" << endl;
					return false;
				}
	
				meshFormat_flag = true;
			}
			else
			{
				break;
			}
		}
	
	
	
		/*--- Read number and names of physical names ---*/
		position = text_line.find("$PhysicalNames",0);
		if(position != string::npos)
		{
			std::getline(*mesh_file, text_line);
			std::istringstream line(text_line);
			
			line >> nPhysicalNames;
			
			//find the specific physical name with the airfoil elements
			for (unsigned int i = 0; i < nPhysicalNames; ++i)
			{
				std::getline(*mesh_file, text_line);
				std::istringstream line(text_line);
				
				string physicalName;
				line >> physicalDimension;
				line >> physicalNumber;
				line >> physicalName;
				
				physicalName.erase(0, 1);
				physicalName.erase(physicalName.length() - 1, physicalName.length());
				if (PhysicalName_airfoil.compare(physicalName) == 0)
				{
					physicalNameFound = true;
					cout << endl << "Physical Name found - OK" << endl;
					break;
				}
			}
			
			if (physicalNameFound == false)
			{
				cout << endl << "Physical Name did not found - failed" << endl;
				//user sucks. FunTom of the Blue Screen
				return false;
			}
		}
		
	
	
		/*--- Read number of points/nodes and the points, of course ---*/
		position = text_line.find("$Nodes",0);
		if(position != string::npos)
		{
			std::getline(*mesh_file, text_line);
			
			/*--- Check for ghost points/nodes .... Actually, I hope it do that because I don't understand why the code is here ... and I think I'm really smart ... really ... but the code is weird. FunTom of the Blue Screen ---*/
			std::stringstream test_line(text_line);
	
			unsigned short iCount = 0;
			unsigned long dummyLong;
			while(test_line >> dummyLong)
				iCount++;
	
			/*--- Now read and store the number of points/nodes and possible ghost points/nodes. ---*/
	
			std::stringstream  point_line(text_line);
			
			//Don't ask me. FunTom of the Blue Screen
			if(iCount == 1 || iCount == 2)
			{
				point_line >> nPoint;
			}
			else
			{
				cout << endl << "Nodes (points) improperly specified - failed" << endl;
				return false;
			}
	
			
			for(unsigned long iPoint = 0 ; iPoint < nPoint; ++iPoint)
			{
				std::getline(*mesh_file, text_line);
				position = text_line.find("$EndNodes",0);
				if(position != string::npos)
				{
					cout << endl << "Unexpected end of the Nodes (points) - breaking the cycle" << endl;
					//Why, user? Why? FunTom of the Blue Screen
					break;
				}
				
				std::istringstream point_line(text_line);
				
				unsigned int index;
				double Coord_2D[2];
				point_line >> index;
				point_line >> Coord_2D[0];
				point_line >> Coord_2D[1];
				//I don't care about the third point. FunTom of the Blue Screen
				Point point = { Coord_2D[0], Coord_2D[1], 0.0 };
				Points.push_back(point);
			}
			
			cout << endl << "Nodes/Points read - OK" << endl;
			//if there was the unexpected end of the nodes, so I hope the nodes were read alright. FunTom of the Blue Screen
		}



		/*--- Read number of elements and the elements ---*/
		position = text_line.find("$Elements",0);
		if(position != string::npos)
		{
			std::getline(*mesh_file, text_line);
			nElements = atoi(text_line.c_str());
	
			//for all elements
			for(unsigned short iElement = 0 ; iElement < nElements; ++iElement)
			{
				std::getline(*mesh_file, text_line);
				position = text_line.find("$EndElements",0);
				if(position != string::npos)
				{
					cout << endl << "Unexpected end of the Elements - breaking the cycle" << endl;
					//Why, user? Why? (really? again?). FunTom of the Blue Screen
					break;
				}
				
				std::istringstream line(text_line);
				
				unsigned int index, physicalDimRead, unimportant1, physicalNumRead, unimportant2, pointX, pointY;
				line >> index;
				line >> physicalDimRead;
				line >> unimportant1;
				line >> physicalNumRead;
				line >> unimportant2;
				line >> pointX;
				line >> pointY;
				
				
				/*--- Physical boundaries definition ---*/
				//in other words: if the element is a point and belongs to the physical group which we're looking for.
				if(physicalDimension == physicalDimRead && physicalNumber == physicalNumRead)
				{
					elementsFound = true;
					
					//index of element list starts with 1 in the MSH file and we need 0 
					Element element = { unimportant2, pointX - 1, pointY - 1 };
					elements.push_back(element);
					
					
				}
				
			}
			
			if (elementsFound == true)
			{
				mesh_file->close();
				cout << endl << "Physical elements found - OK" << endl;
				
				if(this->ConvertFromMesh(Points, elements, normalizeCoordinates) == true)
				{
					cout << endl << "Conversion from mesh - OK" << endl;
					return true;
				}
				else
				{
					cout << endl << "Conversion from mesh - failed" << endl;
					return false;
				}
			}
			else
			{
				cout << endl << "Physical elements was not found - failed" << endl;
			}
		}
	
	}
	/*--- Close the input file ---*/
	mesh_file->close();
	return false;
}



bool Airfoil::ConvertFromMesh(vector<Point> points, vector<Element> elements, bool normalizeCoordinates)
{
	vector<Point> pointsAirfoil;
	
	if (elements.size() > 0 && points.size() > 0)
	{
		for (unsigned int i = 0; i < elements.size(); ++i)
		{
			pointsAirfoil.push_back(points[elements[i].pointN1]);
		}
		
		if (pointsAirfoil.size() == elements.size())
		{
			this->m_UpperPnts.clear();
			this->m_LowerPnts.clear();
			
			
			//find max and min value at x axis from points (it checks also y axis if necessary, i.e. if there are more maxX or minX values or both)
			double maxX = 0;
			double minX = 0;
			unsigned int posMaxX = 0;
			unsigned int posMinX = 0;
			this->FindMaxAndMinX(pointsAirfoil, &maxX, &posMaxX, &minX, &posMinX);
			
			
			/*//this part has been commented from version 0.4.2 - normalization should be done but it is user decision now.
			//check if x interval is <0,1> and if not normalize X and Y values to the interval (we suppose that the y line is 0, so that the airfoil is not transposed along y axis)
			//this must be always done because the output format does not allow exceeding that interval
			if (this->CheckIf_X_IntervalIsOK(maxX, minX) == false)
				this->NormalizeValues(&pointsAirfoil, maxX, minX, 0);
			*/
			
			//normalize X and Y values to the interval <0,1> if normalization is set and necessary (we suppose that the y line is 0, so that the airfoil is not transposed along y axis)
			if (normalizeCoordinates == true && this->CheckIf_X_IntervalIsOK(maxX, minX) == false)
				this->NormalizeValues(&pointsAirfoil, maxX, minX, 0);
			
			
			//find upper and lower side direction and convert the points to the global lower and upper vectors
			//find upper and lower side direction for minX
			int upperDirectionMin = 0, lowerDirectionMin = 0;
			this->FindUpperAndLowerSideDirection(pointsAirfoil, posMinX, &upperDirectionMin, &lowerDirectionMin);
			if (upperDirectionMin == 0 || lowerDirectionMin == 0)
			{
				std::cout << endl << "there are two identical points in input mesh file (for minX)" << endl;
				return false;
			}
			
			//find upper and lower side direction for maxX (only for check - the maxX direction should be opposite to the minX direction)
			int upperDirectionMax = 0, lowerDirectionMax = 0;
			this->FindUpperAndLowerSideDirection(pointsAirfoil, posMaxX, &upperDirectionMax, &lowerDirectionMax);
			if (upperDirectionMax == 0 || lowerDirectionMax == 0)
			{
				std::cout << endl << "there are two identical points in input mesh file (for maxX)" << endl;
				return false;
			}
			
			if (upperDirectionMin == upperDirectionMax && lowerDirectionMin == lowerDirectionMax)
			{
				std::cout << endl << "upper and lower side cannot be in same direction for minX and maxX)" << endl;
				return false;
			}
			
			
			//fill upper and lower vector with the particular points
			this->FillUpperAndLowerVector(pointsAirfoil, posMaxX, posMinX, upperDirectionMin, lowerDirectionMin);
			
			return true;
		}
	}
	
	return false;
}


void Airfoil::FindMaxAndMinX(std::vector<Point> airfoilPoints, double* maxX, unsigned int* posMaxX, double* minX, unsigned int* posMinX)
{
	*maxX = airfoilPoints[0].x;
	*minX = airfoilPoints[0].x;
	*posMaxX = 0;
	*posMinX = 0;
	for (unsigned int i = 1; i < airfoilPoints.size(); ++i)
	{
		if (*maxX < airfoilPoints[i].x)
		{
			*maxX = airfoilPoints[i].x;
			*posMaxX = i;
		}
		else if (*minX > airfoilPoints[i].x)
		{
			*minX = airfoilPoints[i].x;
			*posMinX = i;
		}
		else if (*maxX == airfoilPoints[i].x)
		{
			if (abs(airfoilPoints[*posMaxX].y) > abs(airfoilPoints[i].y))
			{
				*maxX = airfoilPoints[i].x;
				*posMaxX = i;
			}
		}
		else if (*minX == airfoilPoints[i].x)
		{
			if (abs(airfoilPoints[*posMinX].y) > abs(airfoilPoints[i].y))
			{
				*minX = airfoilPoints[i].x;
				*posMinX = i;
			}
		}
	}
}


bool Airfoil::CheckIf_X_IntervalIsOK(double maxX, double minX)
{
	if (maxX != 1)	//in version 0.4.1 -> maxX > 1
		return false;
		
	if (minX != 0)	//in version 0.4.1 -> minX < 0
		return false;
		
	return true;
}


void Airfoil::NormalizeValues(std::vector<Point>* airfoilPoints, double maxX, double minX, double YLine)
{
	for (unsigned int i = 0; i < airfoilPoints->size(); ++i)
	{
		(*airfoilPoints)[i].x = ((*airfoilPoints)[i].x - minX) / (maxX - minX);
		(*airfoilPoints)[i].y = ((*airfoilPoints)[i].y - YLine) / (maxX - minX);
	}
}


void Airfoil::FindUpperAndLowerSideDirection(std::vector<Point> airfoilPoints, unsigned int posX, int* upperDirection, int* lowerDirection)
{
	unsigned int posBack = posX - 1;
	unsigned int posNext = posX + 1;
	
	if (posBack < 0)
		posBack = airfoilPoints.size() - 1;
		
	if (posNext >= airfoilPoints.size())
		posNext = 0;
	
	if (airfoilPoints[posBack].y > airfoilPoints[posNext].y)
	{
		*upperDirection = -1;
		*lowerDirection = 1;
	}
	else if (airfoilPoints[posBack].y < airfoilPoints[posNext].y)
	{
		*upperDirection = 1;
		*lowerDirection = -1;
	}
	else
	{
		//if this option happen, it is suspicious because there are two points with the same y value
		if (airfoilPoints[posBack].x < airfoilPoints[posNext].x)
		{
			*upperDirection = -1;
			*lowerDirection = 1;
		}
		else if (airfoilPoints[posBack].x > airfoilPoints[posNext].x)
		{
			*upperDirection = 1;
			*lowerDirection = -1;
		}
		else
		{
			//this situation means error because there are two identical points (the point cannot be joined with itself)
			*upperDirection = 0;
			*lowerDirection = 0;
		}
	}
}


void Airfoil::FillUpperAndLowerVector(std::vector<Point> airfoilPoints, unsigned int posMaxX, unsigned int posMinX, int upperDirectionMin, int lowerDirectionMin)
{
	
	//check minimal value and add the first value to the specific vectors
	if (airfoilPoints[posMinX].x == 0 && airfoilPoints[posMinX].y == 0)
	{
		this->m_UpperPnts.push_back(airfoilPoints[posMinX]);
		this->m_LowerPnts.push_back(airfoilPoints[posMinX]);
	}
	else
	{
		if (airfoilPoints[posMinX].y > 0)
			this->m_UpperPnts.push_back(airfoilPoints[posMinX]);
		else
			this->m_LowerPnts.push_back(airfoilPoints[posMinX]);
	}
	
	
	
	//added points for upper side of the airfoil
	int position = posMinX + upperDirectionMin;
	//check boundaries and change the position if necessary
	position = this->CheckBoundariesAndGetNextPosition(position, airfoilPoints.size());
	//add the points already
	while (position != (int)posMaxX)
	{
		this->m_UpperPnts.push_back(airfoilPoints[position]);
		
		//check boundaries and change the position if necessary
		position = this->CheckBoundariesAndGetNextPosition(position + upperDirectionMin, airfoilPoints.size());
	}
	
	
	
	//added points for lower side of the airfoil
	position = posMinX + lowerDirectionMin;
	//check boundaries and change the position if necessary
	position = this->CheckBoundariesAndGetNextPosition(position, airfoilPoints.size());
	//add the points already
	while (position != (int)posMaxX)
	{
		this->m_LowerPnts.push_back(airfoilPoints[position]);
		
		//check boundaries and change the position if necessary
		position = this->CheckBoundariesAndGetNextPosition(position + lowerDirectionMin, airfoilPoints.size());
	}
	
	
	
	//check maximal value and add the last value to the specific vectors
	if (airfoilPoints[posMaxX].x == 1 && airfoilPoints[posMaxX].y == 0)
	{
		this->m_UpperPnts.push_back(airfoilPoints[posMaxX]);
		this->m_LowerPnts.push_back(airfoilPoints[posMaxX]);
	}
	else
	{
		if (airfoilPoints[posMaxX].y > 0)
			this->m_UpperPnts.push_back(airfoilPoints[posMaxX]);
		else
			this->m_LowerPnts.push_back(airfoilPoints[posMaxX]);
	}
}


unsigned int Airfoil::CheckBoundariesAndGetNextPosition(int nextPosition, int sizeOfVector)
{
	if (nextPosition > sizeOfVector - 1)
		return 0;
	else if (nextPosition < 0)
		return sizeOfVector - 1;
	else
		return nextPosition;
}




//==== Read Airfoil File ====//
bool Airfoil::ReadFile( string file_name )
{
    //==== Open File ====//
    FILE* file_id =  fopen( file_name.c_str(), "r" );
    if ( file_id == ( FILE * )NULL )
    {
        return false;
    }

    char buff[256];
    string line;

    fgets( buff, 255, file_id );
    line.assign( buff );

    size_t found = line.find( "AIRFOIL FILE" );

    bool valid_file = false;
    if ( found == string::npos )
    {
        valid_file = ReadSeligAirfoil( file_id );           // Check If Selig Format

        if ( !valid_file )
        {
            valid_file = ReadLednicerAirfoil( file_id );    // Check If Lednicer Format
        }
    }
    else
    {
        fgets( buff, 255, file_id );                        // Name
        valid_file = ReadVspAirfoil( file_id );             // VSP Format
    }

    if ( !valid_file )
    {
        fclose( file_id );
        return false;
    }

    //==== Extract Name ====//
    m_AirfoilName.assign( buff );
    StringUtil::change_from_to( m_AirfoilName, '\n', ' ' );
    StringUtil::change_from_to( m_AirfoilName, '\r', ' ' );
    StringUtil::remove_trailing( m_AirfoilName, ' ' );

    fclose( file_id );

    return valid_file;

}


//==== Read Selig Airfoil File ====//
bool Airfoil::ReadSeligAirfoil( FILE* file_id )
{
    int i;
    char buff[256];
    double x, y;

    vector< double > xvec;
    vector< double > yvec;

    int more_data_flag = 1;
    while ( more_data_flag )
    {
        more_data_flag = 0;
        if ( fgets( buff, 255, file_id ) )
        {
            more_data_flag = 1;
        }

        if ( more_data_flag )
        {
            x = y = 100000.0;
            sscanf( buff, "%lf %lf", &x, &y );
            if ( x >= 0.0 && x <= 1.0 && y >= -1.0 && y <= 1.0 )
            {
                xvec.push_back( x );
                yvec.push_back( y );
            }
            else
            {
                more_data_flag = 0;
            }
        }
    }

    int totalPnts = xvec.size();

    if ( totalPnts < 5 )
    {
        return false;
    }

    //==== Find Leading Edge Index ====//
    int leInd = 0;
    double smallestX = 1.0e06;
    for ( i = 0 ; i < totalPnts ; i++ )
    {
        if ( xvec[i] < smallestX )
        {
            smallestX = xvec[i];
            leInd = i;
        }
    }

    //==== Not Enough Pnts ====//
    int num_pnts_lower = totalPnts - leInd;
    int num_pnts_upper = leInd + 1;

    if ( num_pnts_lower < 3 || num_pnts_upper < 3 )
    {
        return false;
    }

    m_UpperPnts.clear();
    m_LowerPnts.clear();

    //==== Load Em Up ====//
    for ( i = leInd ; i >= 0 ; i-- )
    {
		Point point = { xvec[i], yvec[i], 0.0 };
        m_UpperPnts.push_back( point );
    }

    for ( i = leInd ; i < totalPnts ; i++ )
    {
		Point point = { xvec[i], yvec[i], 0.0 };
        m_LowerPnts.push_back( point );
    }

    return true;
}

//==== Read Lednicer Airfoil File ====//
bool Airfoil::ReadLednicerAirfoil( FILE* file_id )
{
    char buff[256];
    double x, y;

    rewind( file_id );

    fgets( buff, 255, file_id );
    fgets( buff, 255, file_id );
    sscanf( buff, "%lf %lf", &x, &y );
    int num_pnts_upper = ( int )( x + 0.5 );
    int num_pnts_lower = ( int )( y + 0.5 );

    if ( num_pnts_upper < 3 || num_pnts_lower < 3 )
    {
        return false;
    }

    m_UpperPnts.clear();
    m_LowerPnts.clear();

    fgets( buff, 255, file_id );
    for ( int i = 0 ; i < num_pnts_upper ; i++ )
    {
        fgets( buff, 255, file_id );
        sscanf( buff, "%lf %lf", &x, &y );
		Point point = { x, y, 0.0 };
        m_UpperPnts.push_back( point );
    }
    fgets( buff, 255, file_id );
    for ( int i = 0 ; i < num_pnts_lower ; i++ )
    {
        fgets( buff, 255, file_id );
        sscanf( buff, "%lf %lf", &x, &y );
		Point point = { x, y, 0.0 };
        m_LowerPnts.push_back( point );
    }

    return true;
}

//==== Read VSP Airfoil File ====//
bool Airfoil::ReadVspAirfoil( FILE* file_id )
{
    int i;
    char buff[256];

    int sym_flag;
    int num_pnts_upper, num_pnts_lower;
    double x, y;

    fgets( buff, 255, file_id );
    sscanf( buff, "%d", &sym_flag );

    fgets( buff, 255, file_id );
    sscanf( buff, "%d", &num_pnts_upper );

    if ( sym_flag )
    {
        num_pnts_lower = num_pnts_upper;
    }
    else
    {
        fgets( buff, 255, file_id );
        sscanf( buff, "%d", &num_pnts_lower );
    }

    m_UpperPnts.clear();
    m_LowerPnts.clear();
    for ( i = 0 ; i < num_pnts_upper ; i++ )
    {
        fgets( buff, 255, file_id );
        sscanf( buff, "%lf %lf", &x, &y );

		Point point = { x, y, 0.0 };
        m_UpperPnts.push_back( point );

        if ( sym_flag )
        {
			Point point2 = { x, -y, 0.0 };
            m_LowerPnts.push_back( point2 );
        }
    }
    fgets( buff, 255, file_id );

    if ( !sym_flag )
    {
        for ( i = 0 ; i < num_pnts_lower ; i++ )
        {
            fgets( buff, 255, file_id );
            sscanf( buff, "%lf %lf", &x, &y );
			Point point = { x, y, 0.0 };
            m_LowerPnts.push_back( point );
        }
    }

    return true;
}

